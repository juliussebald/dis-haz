p_estimate
forest_share_total <- read.csv("../revision/forest_landuse_change.csv")
weird <- forest_share_total %>%
filter(!fs_diff > 0.05 | fs_diff < -0.05)
data_rev <- read.csv("../data/data_for_model.csv") %>%
filter(WLK_ID %in% weird$WLK_ID)
write_csv(data_rev, "../data/data_for_model_rev.csv")
data <- read.csv("../data/data_for_model_rev.csv")
processes <- c("MFL", "FST")
processes_names <- c("Debris flow", "Flood")
vars_ws <- data.frame(varname = c("h_mean", "Melton", "Elevation", "Circularit", "Elongation",
"artifical", "forest", "area", "patchdensity",
"eco_region",
"extent",
"type",
"extent:type"),
name = c("Elevation", "Melton ratio", "Elevation ratio", "Circularity", "Elongation",
"Infrastructure", "Forest cover", "Area", "Patch density",
"Ecological region",
"Extent",
"Type",
"Extent x Type"),
stringsAsFactors = FALSE)
models <- vector("list", length = length(processes))
k <- 0
for (process in processes) {
k <- k + 1
# Bring data into form
vars_nointeraction <- vars_ws %>%
filter(!varname %in% c("extent:type", "eco_region"))
data_model <- data
# make sure that have not excpierienced any disturbances have NA as "disturbance type"
data_model[data_model$extent == 0, "type"] <- NA
# z-transform predictors
data_model <- data_model %>%
mutate_at(.vars = vars(c(vars_nointeraction$varname)), function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE))
# devide dataset in watershed which have had a torrential hazard event (1) and watersheds which had no torrential hazard event (0)
data_model[, "response"] <- ifelse(data_model[, process] > 0, 1, 0)
# make sure that watersheds which have not expierienced any disturbances are set to disturbance type "avarage"
data_model[data_model$extent == min(data_model$extent), "type"] <- 0
# transform eco region predictor to factor
data_model$eco_region <- as.factor(data_model$eco_region)
# Fit null model
fit_null <- stan_glm(response ~ 1,
data = data_model,
family = binomial,
prior = normal(0, 0.5, autoscale = TRUE),
prior_intercept = normal(0, 0.5, autoscale = TRUE),
prior_aux = exponential(rate = 1, autoscale = TRUE))
# Calculate loo for null model
loo_fit_null <- loo(fit_null)
# Fit general model
fit_general <- update(fit_null, . ~ . + area + h_mean + artifical + eco_region, QR = TRUE)
# Calculate loo for general model
loo_fit_general <- loo(fit_general)
# Fit general+geomorph model
fit_general_geomorph <- update(fit_general, . ~ . + Elevation + Melton + Circularit + Elongation, QR = TRUE)
# Calculate loo for general+geomorph model
loo_fit_general_geomorph <- loo(fit_general_geomorph)
# Fit general+geomorph+forest model
fit_general_geomorph_forest <- update(fit_general_geomorph, . ~ . + forest + patchdensity, QR = TRUE)
# Calculate loo for general+geomorph+forest model
loo_fit_general_geomorph_forest <- loo(fit_general_geomorph_forest)
# Fit general+geomorph+forest-disturbance model
fit_general_geomorph_forest_disturbances <- update(fit_general_geomorph_forest, . ~ . + extent * type)
# Calculate loo for full model
loo_fit_general_geomorph_forest_disturbances <- loo(fit_general_geomorph_forest_disturbances)
# compare watershed model and full model
model_comparison <- loo::compare(loo_fit_null,
loo_fit_general,
loo_fit_general_geomorph,
loo_fit_general_geomorph_forest,
loo_fit_general_geomorph_forest_disturbances)
model_comparison_direct <- list(loo::compare(loo_fit_null,
loo_fit_general),
loo::compare(loo_fit_general,
loo_fit_general_geomorph),
loo::compare(loo_fit_general_geomorph,
loo_fit_general_geomorph_forest),
loo::compare(loo_fit_general_geomorph_forest,
loo_fit_general_geomorph_forest_disturbances))
model_comparison_direct <- model_comparison_direct %>%
map(~ as.vector(.)) %>%
set_names(c("General",
"Geomorph",
"Forest",
"Disturbances")) %>%
bind_rows() %>%
t() %>%
as.data.frame() %>%
rename_("ELPD difference" = "V1", "SE" = "V2")
# Store everything in a list
models[[k]] <- list(list(fit_null,
fit_general,
fit_general_geomorph,
fit_general_geomorph_forest,
fit_general_geomorph_forest_disturbances),
list(loo_fit_null,
loo_fit_general,
loo_fit_general_geomorph,
loo_fit_general_geomorph_forest,
loo_fit_general_geomorph_forest_disturbances),
model_comparison,
model_comparison_direct)
}
final_models <- models %>% map(., ~ .[[1]][[5]])
estimates <- final_models %>%
map(~ as.data.frame(.) %>%
dplyr::select(-matches("Intercept")) %>% # Select everything that is not an intercept
gather(key = varname, value = value) %>%
left_join(vars_ws, by = "varname")) %>%
set_names(processes_names) %>%
bind_rows(.id = "process") %>%
filter(!varname %in% c(paste0("eco_region", 1:9), "reciprocal_dispersion")) %>%
mutate(name = factor(name, levels = c("Area", "Infrastructure", "Elevation", "Elevation ratio", "Circularity",
"Melton ratio", "Elongation", "Forest cover", "Patch density", "Extent",
"Type", "Extent x Type"))) %>%
mutate(type = case_when(name %in% c("Area", "Elevation", "Infrastructure") ~ "General",
name %in% c ("Elevation ratio", "Circularity", "Melton ratio", "Elongation") ~ "Geomorphology",
name %in% c("Forest cover", "Patch density", "Extent", "Type", "Extent x Type") ~ "Forest")) %>%
mutate(type = factor(type, levels = c("General", "Geomorphology", "Forest")))
p_estimates <- ggplot(estimates, aes(x = fct_rev(name), y = value)) +
geom_violin(aes(fill = paste0("  ", type))) +
theme_bw() +
theme(panel.grid = element_blank(),
strip.background = element_blank()) +
coord_flip() +
theme(strip.background = element_blank()) +
geom_hline(yintercept = 0, linetype = "dashed", col = scales::muted("red")) +
labs(y = "Posterior probability distribution of parameter estimates", x = NULL) +
facet_wrap(~process) +
scale_fill_manual(values = c("#276419","#ffffbf", "#4393c3"), breaks = c("  General", "  Geomorphology", "  Forest" )) +
theme(legend.title = element_blank())
p_estimates
estimates$model <- "count"
write_csv(estimates, "../results/count/estimates_count_rev.csv")
estimates <- list.files("../results/", glob2rx("estimates*.csv"), recursive = TRUE, full.names = TRUE) %>%
map(read_csv) %>%
bind_rows() %>%
mutate(name = factor(name, levels = c("Infrastructure", "Elevation","Area",
"Elevation ratio", "Circularity", "Melton ratio", "Elongation",
"Extent x Type", "Extent", "Type", "Patch density", "Forest cover")))
p_estimate <- list(a = estimates %>%
mutate(type = case_when(name %in% c("Forest cover", "Patch density") ~ "Forest",
name %in% c("Extent x Type", "Extent", "Type") ~ "Disturbance",
TRUE ~ type)) %>%
mutate(type = factor(type, levels = c("General", "Geomorphology", "Forest", "Disturbance"))) %>%
mutate(model = factor(model, labels = c("Occurrence", "Frequency"))) %>%
split(.$type),
b = list(NULL, NULL, NULL, "Effect size"),
c = list(element_blank(), element_blank(), element_blank(), element_text()),
d = list(element_text(size = 10), element_blank(), element_blank(), element_blank()),
e = list(element_blank(), element_blank(), element_blank(), element_line()),
f = list("right", "none", "none", "none")) %>%
pmap(.l = ., .f = function (a, b, c, d, e, f) {
ggplot(a, aes(x = name, y = value)) +
geom_violin(aes(fill = model)) +
theme_bw() +
theme(legend.position = f,
legend.title = element_text(size = 9),
panel.grid = element_blank(),
strip.background = element_blank(),
strip.text.x = d,
strip.text.y = element_text(size = 10),
axis.ticks.x = e,
axis.text.y = element_text(size = 10, colour = "black"),
axis.text.x = c,
plot.margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "pt")) +
coord_flip() +
geom_hline(yintercept = 0, linetype = "dashed", col = scales::muted("red")) +
labs(y = b, x = NULL, fill = "Model") +
facet_grid(type~process) +
ylim(-0.9, 0.9) +
scale_fill_brewer(palette = "Greys") +
guides(fill = guide_legend(ncol = 1,
keywidth = 0.15,
keyheight = 0.1,
default.unit = "inch"))
}) %>%
wrap_plots(ncol = 1, heights = c(1, 1.2, 0.6, 1))
p_estimate
rm(list=ls())
shp_ws <- read_sf("../shp_ws.shp")
shp_ws <- read_sf("../revision/shape_files/shp_ws.shp")
rm(list=ls())
forest_share_total <- read.csv("../revision/forest_landuse_change.csv")
weird <- forest_share_total %>%
filter(!fs_diff > 0.05 | fs_diff < -0.05)
data_rev <- read.csv("../data/data_for_model.csv") %>%
filter(WLK_ID %in% weird$WLK_ID)
write_csv(data_rev, "../data/data_for_model_rev.csv")
Sys.setenv(USE_CXX14 = 1)
library(raster) # version 2.6-7
library(sp) # version 1.3-1
library(rgdal) # version 1.3-4
library(igraph) # version 1.2.2
library(tidyverse) # version 1.2.1
library(rstanarm) # version 2.17.4
library(projpred )# version 0.8.0
library(multiscales) # version 0.1.0 # devtools::install_github("clauswilke/multiscales")
library(patchwork) # version 0.0.1
library(rstan) # version 2.17.4
library(sf) # version 0.6-3
library(gridExtra) # version 2.3
library(ggthemes)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
rm(list=ls())
data <- read.csv("../data/data_for_model_rev.csv")
processes <- c("MFL", "FST")
processes_names <- c("Debris flow", "Flood")
vars_ws <- data.frame(varname = c("h_mean", "Melton", "Elevation", "Circularit", "Elongation",
"artifical", "forest", "area", "patchdensity",
"eco_region",
"extent",
"type",
"extent:type"),
name = c("Elevation", "Melton ratio", "Elevation ratio", "Circularity", "Elongation",
"Infrastructure", "Forest cover", "Area", "Patch density",
"Ecological region",
"Extent",
"Type",
"Extent x Type"),
stringsAsFactors = FALSE)
models <- vector("list", length = length(processes))
k <- 0
for (process in processes) {
k <- k + 1
# Bring data into form
vars_nointeraction <- vars_ws %>%
filter(!varname %in% c("extent:type", "eco_region"))
data_model <- data
# make sure that have not excpierienced any disturbances have NA as "disturbance type"
data_model[data_model$extent == 0, "type"] <- NA
# z-transform predictors
data_model <- data_model %>%
mutate_at(.vars = vars(c(vars_nointeraction$varname)), function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE))
# devide dataset in watershed which have had a torrential hazard event (1) and watersheds which had no torrential hazard event (0)
data_model[, "response"] <- ifelse(data_model[, process] > 0, 1, 0)
# make sure that watersheds which have not expierienced any disturbances are set to disturbance type "avarage"
data_model[data_model$extent == min(data_model$extent), "type"] <- 0
# transform eco region predictor to factor
data_model$eco_region <- as.factor(data_model$eco_region)
# Fit null model
fit_null <- stan_glm(response ~ 1,
data = data_model,
family = binomial,
prior = normal(0, 0.5, autoscale = TRUE),
prior_intercept = normal(0, 0.5, autoscale = TRUE),
prior_aux = exponential(rate = 1, autoscale = TRUE))
# Calculate loo for null model
loo_fit_null <- loo(fit_null)
# Fit general model
fit_general <- update(fit_null, . ~ . + area + h_mean + artifical + eco_region, QR = TRUE)
# Calculate loo for general model
loo_fit_general <- loo(fit_general)
# Fit general+geomorph model
fit_general_geomorph <- update(fit_general, . ~ . + Elevation + Melton + Circularit + Elongation, QR = TRUE)
# Calculate loo for general+geomorph model
loo_fit_general_geomorph <- loo(fit_general_geomorph)
# Fit general+geomorph+forest model
fit_general_geomorph_forest <- update(fit_general_geomorph, . ~ . + forest + patchdensity, QR = TRUE)
# Calculate loo for general+geomorph+forest model
loo_fit_general_geomorph_forest <- loo(fit_general_geomorph_forest)
# Fit general+geomorph+forest-disturbance model
fit_general_geomorph_forest_disturbances <- update(fit_general_geomorph_forest, . ~ . + extent * type)
# Calculate loo for full model
loo_fit_general_geomorph_forest_disturbances <- loo(fit_general_geomorph_forest_disturbances)
# compare watershed model and full model
model_comparison <- loo::compare(loo_fit_null,
loo_fit_general,
loo_fit_general_geomorph,
loo_fit_general_geomorph_forest,
loo_fit_general_geomorph_forest_disturbances)
model_comparison_direct <- list(loo::compare(loo_fit_null,
loo_fit_general),
loo::compare(loo_fit_general,
loo_fit_general_geomorph),
loo::compare(loo_fit_general_geomorph,
loo_fit_general_geomorph_forest),
loo::compare(loo_fit_general_geomorph_forest,
loo_fit_general_geomorph_forest_disturbances))
model_comparison_direct <- model_comparison_direct %>%
map(~ as.vector(.)) %>%
set_names(c("General",
"Geomorph",
"Forest",
"Disturbances")) %>%
bind_rows() %>%
t() %>%
as.data.frame() %>%
rename_("ELPD difference" = "V1", "SE" = "V2")
# Store everything in a list
models[[k]] <- list(list(fit_null,
fit_general,
fit_general_geomorph,
fit_general_geomorph_forest,
fit_general_geomorph_forest_disturbances),
list(loo_fit_null,
loo_fit_general,
loo_fit_general_geomorph,
loo_fit_general_geomorph_forest,
loo_fit_general_geomorph_forest_disturbances),
model_comparison,
model_comparison_direct)
}
save(models, file = "../results/binomial/models_binomial_rev.RData")
final_models <- models %>% map(., ~ .[[1]][[5]])
estimates <- final_models %>%
map(~ as.data.frame(.) %>%
dplyr::select(-matches("Intercept")) %>% # Select everything that is not an intercept
gather(key = varname, value = value) %>%
left_join(vars_ws, by = "varname")) %>%
set_names(processes_names) %>%
bind_rows(.id = "process") %>%
filter(!varname %in% c(paste0("eco_region", 1:9))) %>%
mutate(name = factor(name, levels = c("Area", "Infrastructure", "Elevation", "Elevation ratio", "Circularity",
"Melton ratio", "Elongation", "Forest cover", "Patch density", "Extent",
"Type", "Extent x Type"))) %>%
mutate(type = case_when(name %in% c("Area", "Elevation", "Infrastructure") ~ "General",
name %in% c ("Elevation ratio", "Circularity", "Melton ratio", "Elongation") ~ "Geomorphology",
name %in% c("Forest cover", "Patch density", "Extent", "Type", "Extent x Type") ~ "Forest")) %>%
mutate(type = factor(type, levels = c("General", "Geomorphology", "Forest")))
estimates$model <- "binomial"
write_csv(estimates, "../results/binomial/estimates_binomial_rev.csv")
rm(list=ls())
{
Sys.setenv(USE_CXX14 = 1)
library(raster) # version 2.6-7
library(sp) # version 1.3-1
library(rgdal) # version 1.3-4
library(igraph) # version 1.2.2
library(tidyverse) # version 1.2.1
library(rstanarm) # version 2.17.4
library(projpred )# version 0.8.0
library(multiscales) # version 0.1.0 # devtools::install_github("clauswilke/multiscales")
library(patchwork) # version 0.0.1
library(rstan) # version 2.17.4
library(sf) # version 0.6-3
library(gridExtra) # version 2.3
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
rm(list=ls())
}
data <- read.csv("../data/data_for_model_rev.csv")
processes <- c("MFL", "FST")
processes_names <- c("Debris flow", "Flood")
vars_ws <- data.frame(varname = c("h_mean", "Melton", "Elevation", "Circularit", "Elongation",
"artifical", "forest", "area", "patchdensity",
"eco_region",
"extent",
"type",
"extent:type"),
name = c("Elevation", "Melton ratio", "Elevation ratio", "Circularity", "Elongation",
"Infrastructure", "Forest cover", "Area", "Patch density",
"Ecological region",
"Extent",
"Type",
"Extent x Type"),
stringsAsFactors = FALSE)
models <- vector("list", length = length(processes))
k <- 0
for (process in processes) {
k <- k + 1
# Bring data into form
vars_nointeraction <- vars_ws %>%
filter(!varname %in% c("extent:type", "eco_region"))
data_model <- data
# make sure that have not excpierienced any disturbances have NA as "disturbance type"
data_model[data_model$extent == 0, "type"] <- NA
# z-transform predictors
data_model <- data_model %>%
mutate_at(.vars = vars(c(vars_nointeraction$varname)), function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE))
# devide dataset in watershed which have had a torrential hazard event (1) and watersheds which had no torrential hazard event (0)
data_model[, "response"] <- data_model[, process]
# make sure that watersheds which have not expierienced any disturbances are set to disturbance type "avarage"
data_model[data_model$extent == min(data_model$extent), "type"] <- 0
# transform eco region predictor to factor
data_model$eco_region <- as.factor(data_model$eco_region)
# Fit null model
fit_null <- stan_glm(response ~ 1,
data = data_model,
family = neg_binomial_2,
prior = normal(0, 0.5, autoscale = TRUE),
prior_intercept = normal(0, 0.5, autoscale = TRUE),
prior_aux = exponential(rate = 1, autoscale = TRUE))
# Calculate loo for null model
loo_fit_null <- loo(fit_null)
# Fit general model
fit_general <- update(fit_null, . ~ . + area + h_mean + artifical + eco_region, QR = TRUE)
# Calculate loo for general model
loo_fit_general <- loo(fit_general)
# Fit general+geomorph model
fit_general_geomorph <- update(fit_general, . ~ . + Elevation + Melton + Circularit + Elongation, QR = TRUE)
# Calculate loo for general+geomorph model
loo_fit_general_geomorph <- loo(fit_general_geomorph)
# Fit general+geomorph+forest model
fit_general_geomorph_forest <- update(fit_general_geomorph, . ~ . + forest + patchdensity, QR = TRUE)
# Calculate loo for general+geomorph+forest model
loo_fit_general_geomorph_forest <- loo(fit_general_geomorph_forest)
# Fit general+geomorph+forest-disturbance model
fit_general_geomorph_forest_disturbances <- update(fit_general_geomorph_forest, . ~ . + extent * type)
# Calculate loo for full model
loo_fit_general_geomorph_forest_disturbances <- loo(fit_general_geomorph_forest_disturbances)
# compare watershed model and full model
model_comparison <- loo::compare(loo_fit_null,
loo_fit_general,
loo_fit_general_geomorph,
loo_fit_general_geomorph_forest,
loo_fit_general_geomorph_forest_disturbances)
model_comparison_direct <- list(loo::compare(loo_fit_null,
loo_fit_general),
loo::compare(loo_fit_general,
loo_fit_general_geomorph),
loo::compare(loo_fit_general_geomorph,
loo_fit_general_geomorph_forest),
loo::compare(loo_fit_general_geomorph_forest,
loo_fit_general_geomorph_forest_disturbances))
model_comparison_direct <- model_comparison_direct %>%
map(~ as.vector(.)) %>%
set_names(c("General",
"Geomorph",
"Forest",
"Disturbances")) %>%
bind_rows() %>%
t() %>%
as.data.frame() %>%
rename_("ELPD difference" = "V1", "SE" = "V2")
# Store everything in a list
models[[k]] <- list(list(fit_null,
fit_general,
fit_general_geomorph,
fit_general_geomorph_forest,
fit_general_geomorph_forest_disturbances),
list(loo_fit_null,
loo_fit_general,
loo_fit_general_geomorph,
loo_fit_general_geomorph_forest,
loo_fit_general_geomorph_forest_disturbances),
model_comparison,
model_comparison_direct)
}
save(models, file = "../results/count/models_count_rev.RData")
load(file =  "../results/count/models_count.RData")
final_models <- models %>% map(., ~ .[[1]][[5]])
estimates <- final_models %>%
map(~ as.data.frame(.) %>%
dplyr::select(-matches("Intercept")) %>% # Select everything that is not an intercept
gather(key = varname, value = value) %>%
left_join(vars_ws, by = "varname")) %>%
set_names(processes_names) %>%
bind_rows(.id = "process") %>%
filter(!varname %in% c(paste0("eco_region", 1:9), "reciprocal_dispersion")) %>%
mutate(name = factor(name, levels = c("Area", "Infrastructure", "Elevation", "Elevation ratio", "Circularity",
"Melton ratio", "Elongation", "Forest cover", "Patch density", "Extent",
"Type", "Extent x Type"))) %>%
mutate(type = case_when(name %in% c("Area", "Elevation", "Infrastructure") ~ "General",
name %in% c ("Elevation ratio", "Circularity", "Melton ratio", "Elongation") ~ "Geomorphology",
name %in% c("Forest cover", "Patch density", "Extent", "Type", "Extent x Type") ~ "Forest")) %>%
mutate(type = factor(type, levels = c("General", "Geomorphology", "Forest")))
estimates$model <- "count"
write_csv(estimates, "../results/count/estimates_count_rev.csv")
rm(list=ls())
estimates <- list.files("../results/", glob2rx("estimates*.csv"), recursive = TRUE, full.names = TRUE) %>%
map(read_csv) %>%
bind_rows() %>%
mutate(name = factor(name, levels = c("Infrastructure", "Elevation","Area",
"Elevation ratio", "Circularity", "Melton ratio", "Elongation",
"Extent x Type", "Extent", "Type", "Patch density", "Forest cover")))
p_estimate <- list(a = estimates %>%
mutate(type = case_when(name %in% c("Forest cover", "Patch density") ~ "Forest",
name %in% c("Extent x Type", "Extent", "Type") ~ "Disturbance",
TRUE ~ type)) %>%
mutate(type = factor(type, levels = c("General", "Geomorphology", "Forest", "Disturbance"))) %>%
mutate(model = factor(model, labels = c("Occurrence", "Frequency"))) %>%
split(.$type),
b = list(NULL, NULL, NULL, "Effect size"),
c = list(element_blank(), element_blank(), element_blank(), element_text()),
d = list(element_text(size = 10), element_blank(), element_blank(), element_blank()),
e = list(element_blank(), element_blank(), element_blank(), element_line()),
f = list("right", "none", "none", "none")) %>%
pmap(.l = ., .f = function (a, b, c, d, e, f) {
ggplot(a, aes(x = name, y = value)) +
geom_violin(aes(fill = model)) +
theme_bw() +
theme(legend.position = f,
legend.title = element_text(size = 9),
panel.grid = element_blank(),
strip.background = element_blank(),
strip.text.x = d,
strip.text.y = element_text(size = 10),
axis.ticks.x = e,
axis.text.y = element_text(size = 10, colour = "black"),
axis.text.x = c,
plot.margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "pt")) +
coord_flip() +
geom_hline(yintercept = 0, linetype = "dashed", col = scales::muted("red")) +
labs(y = b, x = NULL, fill = "Model") +
facet_grid(type~process) +
ylim(-0.9, 0.9) +
scale_fill_brewer(palette = "Greys") +
guides(fill = guide_legend(ncol = 1,
keywidth = 0.15,
keyheight = 0.1,
default.unit = "inch"))
}) %>%
wrap_plots(ncol = 1, heights = c(1, 1.2, 0.6, 1))
p_estimate
ggsave("../results/estimates_combined_without_landuse_change.pdf", p_estimate, width = 5.5, height = 4.5)
ggsave("../results/estimates_combined_without_landuse_change.png", p_estimate, width = 5.5, height = 4.5)
data <- read.csv("../data/data_for_model_rev.csv")
10885-8644
